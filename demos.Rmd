---
title: '*jumbled* demonstrations'
output: pdf_document
author: Sasha D. Hafner
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

# Overview
This document demonstrates usage of some of the function in the jumbled repo, available from [github.com/sashahafner/jumbled](github.com/sashahafner/jumbled).

# Load functions

```{r}
ff <- list.files(pattern = '\\.R$')
for(i in ff) source(i)
```

# aggregate2
A wrapper for `aggregate` that accepts multiple functions and simpler arguments.
Does not accept formula notation.

Example from `aggregate` help file:
```{r}
aggregate(breaks ~ wool + tension, data = warpbreaks, mean)
```

To include sd and n, use `aggregate2`:
```{r}
aggregate2(warpbreaks, x = 'breaks', by = c('wool', 'tension'), 
           FUN = list(mean = mean, sd = sd, n = length))
```

Accepts multiple variables (as in `aggregate`).

```{r}
aggregate2(na.omit(airquality), x = c('Ozone', 'Temp'), by = 'Month', 
	   FUN = list(mean = mean, sd = sd, n = length))
```

# aggregate3

Similar, but uses formula notation.
Example from `aggregate` help file:

```{r}
aggregate(breaks ~ wool + tension, data = warpbreaks, mean)
```

To include sd and n, use `aggregate3`:

```{r}
aggregate3(warpbreaks, breaks ~ wool + tension, 
	   FUN = list(mean = mean, sd = sd, n = length))
```

For multiple response variables, use `cbind()`.

```{r}
aggregate3(airquality, cbind(Ozone, Temp) ~ Month, 
	   FUN = list(mean = mean, sd = sd, n = length))
```

So `Ozone + Temp ~ Month` doesn't work, because `aggregate()` can't handle it propertly.
It would be nice to address this limitation in the future.

# dfcombos
Something like `expand.grid` for data frames.
Can accept vectors too, but resulting name is poor.

```{r}
d1 <- data.frame(name = letters[1:5], x = 1.1)
d2 <- data.frame(b = 1:3)
dfcombos(d1, d2)

v1 <- c(TRUE, FALSE)
dfcombos(d1, d2, v1)
```

# dfsumm
Generate a data frame summary more detailed and compact than `summary` output.

```{r}
dfsumm(attenu)
```

Compare to `summary`.

```{r}
summary(attenu)
```

# interpm
Fill in missing observations for multiple columns via interpolation.
`interpm` calls `approx`.

```{r}
args(interpm)
```


```{r}
dat <- data.frame(time = 1:30, a = rnorm(30), b = rnorm(30), c = rnorm(30))
dat[5:10, -1] <- NA
dat[20:22, 'a'] <- NA

dat

dat2 <- interpm(dat, 'time', c('a', 'b', 'c'))

dat2

plot(a ~ time, data = dat)
points(a ~ time, data = dat2, cex = 0.5, col = 'blue')
```

Now woks for data.tables too.

```{r}
dat <- data.table::as.data.table(dat)
dat2 <- interpm(dat, 'time', c('a', 'b', 'c'))
```

```{r}
dat <- data.frame(time = rep(1:10, 3), group = rep(c('a', 'b', 'c'), each = 10), a = rnorm(30), b = rnorm(30), c = rnorm(30))
dat[5:9, -1:-2] <- NA
dat[c(20, 22), 'a'] <- NA

dat
```

```{r}
interpm(dat, 'time', c('a', 'b', 'c'), by = 'group')
```

```{r}
interpm(dat, 'time', c('a', 'b', 'c'), by = 'group', rule = 2)
```

```{r}
dat <- data.table::as.data.table(dat)
dat
```

```{r}
interpm(dat, 'time', c('a', 'b', 'c'), by = 'group')
```

```{r}
interpm(dat, 'time', c('a', 'b', 'c'), by = 'group', rule = 2)
```


# logaxis
Add log axis to base R plots.

# logistic
The logistic function for transformations.

# rbindf
Like `rbind` but data frame columns do not need to match.
From monitoR package.

# rounddf
Round complete data frames.

```{r}
dat <- data.frame(a = 1:10, b = rnorm(10), c = letters[1:10])
dat


rounddf(dat)
rounddf(dat, digits = c(0, 4))
rounddf(dat, digits = c(0, 4), func = signif)
rounddf(dat, digits = c(2, 2), func = signif)
```

Trailing zeroes are dropped when written out (although this does not show up in R console).
Avoid with `pad = TRUE`, which converts adds trailing zeroes and converts column to character.


```{r}
set.seed(124)
dat <- data.frame(a = 1:10, b = rnorm(10), c = letters[1:10])
dat
summary(dat)

rounddf(dat)
rounddf(dat, pad = TRUE)
dat <- rounddf(dat, pad = TRUE)
summary(dat)
```



## `ggsave2x`
Save a ggplot2 figure in more than one format in a single call.

```{r}
library(ggplot2)
ggplot(economics, aes(date, unemploy)) +
  geom_line(colour = "red")
```

```{r, eval=FALSE}
ggsave2x('economics', width = 5, height = 5)
```

Saves png and pdf by default, add more with `type` argument.
Use `...` optional arguments for more flexibility.


## `fintegrate`
Integrate *f*lux measurements for emission.

```{r}
source('fintegrate.R')
```

### 1. Linear

```{r}
x <- 0:10
y <- 0:10
plot(x, y)
```

Exact integral is `10 * 10 / 2 = 50`.

```{r}
fintegrate(x, y, 'midpoint')
fintegrate(x, y, 'left')
fintegrate(x, y, 'right')
fintegrate(x, y, 'trap')
```

Note differences on the way up.

```{r}
plot(0:10, fintegrate(x, y, 'midpoint'), ylim = c(0, 60))
lines(0:10, fintegrate(x, y, 'left'), col = 'red')
lines(0:10, fintegrate(x, y, 'right'), col = 'blue')
lines(0:10, fintegrate(x, y, 'trap'), col = 'green')
```

Leave out 0 (say first measurement is at time = 1).

```{r}
x <- 1:10
y <- 1:10
plot(x, y)
```

Exact integral depends on what occurred before t = 1.

```{r}
fintegrate(x, y, 'midpoint')
fintegrate(x, y, 'left')
fintegrate(x, y, 'right')
fintegrate(x, y, 'trap')
```

Can incorporate assumptions.

```{r}
fintegrate(x, y, 'midpoint', start = 0)
fintegrate(x, y, 'left', start = 0)
fintegrate(x, y, 'right', start = 0)
fintegrate(x, y, 'trap', start = 0, ystart = 0)
```

# Nonlinear

```{r}
x <- 1:10
y <- exp(-x)
plot(x, y, type = 'l')
```

Exact integral from 1:10 is `exp(-10) - exp(-1)` = 0.3678.
From 0 it is 1.0.

```{r}
fintegrate(x, y, 'midpoint', value = 'total')
fintegrate(x, y, 'left', value = 'total')
fintegrate(x, y, 'right', value = 'total')
fintegrate(x, y, 'trap', value = 'total')
```

None does very well.

Start at 0.

```{r}
x <- 0:10
y <- exp(-x)
plot(x, y, type = 'l')
```

```{r}
fintegrate(x, y, 'midpoint', value = 'total')
fintegrate(x, y, 'left', value = 'total')
fintegrate(x, y, 'right', value = 'total')
fintegrate(x, y, 'trap', value = 'total')
```

Prove that all methods become accurate with very high resolution.

```{r}
x <- 0:100 / 10
y <- exp(-x)
plot(x, y, type = 'l')
```

```{r}
fintegrate(x, y, 'midpoint', value = 'total')
fintegrate(x, y, 'left', value = 'total')
fintegrate(x, y, 'right', value = 'total')
fintegrate(x, y, 'trap', value = 'total')
```

```{r}
x <- 0:10000 / 1000
y <- exp(-x)
plot(x, y, type = 'l')
```

```{r}
fintegrate(x, y, 'midpoint', value = 'total')
fintegrate(x, y, 'left', value = 'total')
fintegrate(x, y, 'right', value = 'total')
fintegrate(x, y, 'trap', value = 'total')
```





```{r}
dd <- data.frame(x = c(1, 2, 5, 3, 10), y = c(10, 20, 5, 0, 15))

dd <- data.frame(x = c(1, 2, 3, 5, 10), y = c(10, 20, 0, 5, 15))

dd <- data.frame(x = 1:10, y = 1:10)

x <- dd$x
y <- dd$y
start <- 0
end <- 20

fintegrate(dd$x, dd$y, 'midpoint')
fintegrate(dd$x, dd$y, 'left')
fintegrate(dd$x, dd$y, 'right')
fintegrate(dd$x, dd$y, 'trap')

```

